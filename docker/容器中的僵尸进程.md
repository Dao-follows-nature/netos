# 容器中的僵尸进程

## 什么是僵尸进程

1. 进程已经退出。但其父进程尚未对它们进行资源回收操作
2. 其父进程没有等待它们（父进程使用 wait 系统调用来获取子进程的退出代码）。
3. 进程失去了父进程（即其父进程也已退出），这意味着它们将永远不会被其父进程等待。

当一个进程创建了一个子进程，并且后者完成了其任务后，子进程的退出状态需要被父进程获取（通常通过`wait()`系统调用）。如果父进程没有及时对子进程进行善后处理，子进程就会变成僵尸进程。

如果父进程没有及时处理僵尸进程，可能会导致系统中存在大量的僵尸进程，**占用系统资源（如进程ID等）**，尽管它们并不消耗 CPU 或内存资源。

为了避免僵尸进程的过多积累，父进程应该及时调用适当的系统调用（如`wait()`或`waitpid()`）来获取子进程的退出状态，并进行善后处理。这样可以确保僵尸进程被及时清理，释放相关的系统资源。

## 僵尸进程会产生什么危害

- 进程号
- 文件描述符

在linux 系统中 的进程总数目是有限制的。如果超过这个最大值，那么系统就无法创建 出新的进程了，比如你将无法ssh远程连接 或无法执行linux命令

查看linux 默认的进程总数

```
cat  /proc/sys/kernel/pid_max
```

Linux 内核在初始化系统的时候，会根据机器 CPU 的数目来设置 pid_max 的值。 比如说，如果机器中 CPU 数目小于等于 32，那么 pid_max 就会被设置为 32768（32K）；如果机器中的 CPU 数目大于 32，那么 pid_max 就被设置为 N*1204 （N 就是 CPU 数目）。 

对于 Linux 系统而言，容器就是一组进程的集合。如果容器中的应用创建过多的进程或者 出现 bug，就会产生类似 fork bomb 的行为。

 这个 fork bomb 就是指在计算机中，通过不断建立新进程来消耗系统中的进程资源，它是 一种黑客攻击方式。

这样，容器中的进程数就会把整个节点的可用进程总数给消耗完。 这样，不但会使同一个节点上的其他容器无法工作，还会让宿主机本身也无法工作。所以 对于每个容器来说，我们都需要限制它的最大进程数目，而这个功能由 pids Cgroup 这个 子系统来完成。

## 为什么会产生僵尸进程

在容器中，通常会使用进程1（PID 1）作为容器的主进程，负责启动和管理容器内的其他进程。相当于宿主机中的 init 或systemd 。也就是说容器内的1号进程在子进程退出后并没有调用适当的系统调用（如`wait()`或`waitpid()`）来回收子进程。建议用waitpid()，因为wait() 系统调用是一个阻塞的调用，也就是说，如果没有子进程是僵尸进程的话，这个调 用就一直不会返回，那么整个进程就会被阻塞住，而不能去做别的事了。

每个 Docker 容器都是一个 PID 命名空间，这意味着容器中的进程与主机上的其他进程隔离。PID 命名空间是一棵树，从 PID 1 开始，通常称为`init`.

注意：当您运行 Docker 容器时，PID 1 是您设置的任何内容`ENTRYPOINT`（或者如果您没有，那么它是您的 shell 或另一个程序，具体取决于您的格式`CMD`）。

现在，与其他进程不同，PID 1有一个独特的职责，那就是收割僵尸进程。

## 如何解决

[tini 容器init](https://github.com/krallin/tini) 是一个最小化的 `init` 系统，运行在容器内部，用于启动一个子进程，并等待进程退出时清理僵尸和执行信号转发。

Tini的优点:

- tini可以避免应用程序生成僵尸进程
- tini可以处理Docker进程中运行的程序的信号，例如，通过Tini， `SIGTERM` 可以终止进程，不需要你明确安装一个信号处理器

> 创建僵尸通常首先会受到反对（即理想情况下，您应该**修复代码**，这样它就不会创建僵尸
>





